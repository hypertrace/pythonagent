<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>hypertrace.agent.instrumentation.fast_api API documentation</title>
<meta name="description" content="includes a middleware.__call__ wrapper and the fast api instrumentor implementation + hooks" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hypertrace.agent.instrumentation.fast_api</code></h1>
</header>
<section id="section-intro">
<p>includes a middleware.<strong>call</strong> wrapper and the fast api instrumentor implementation + hooks</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;includes a middleware.__call__ wrapper and the fast api instrumentor implementation + hooks&#34;&#34;&#34;
import logging
from functools import wraps

from fastapi import HTTPException
from starlette.datastructures import Headers
from starlette.requests import Request
from starlette.responses import PlainTextResponse

from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor
from opentelemetry.instrumentation.asgi import OpenTelemetryMiddleware, set_status_code
from opentelemetry.instrumentation.asgi import get_host_port_url_tuple, \
    context, asgi_getter, trace, collect_request_attributes

from opentelemetry.propagate import extract

from hypertrace.agent.filter.registry import Registry, TYPE_HTTP
from hypertrace.agent.instrumentation import BaseInstrumentorWrapper

logger = logging.getLogger(__name__)  # pylint: disable=C0103


# We need to replace the entire __call__ method so that we can
# pull the req body from the original requests receive
async def replaced_ot_middleware_call(self, scope, receive, send): # pylint:disable=R0914
    &#34;&#34;&#34;The ASGI application

    Args:
        scope: A ASGI environment.
        receive: An awaitable callable yielding dictionaries
        send: An awaitable callable taking a single dictionary as argument.
    &#34;&#34;&#34;
    if scope[&#34;type&#34;] not in (&#34;http&#34;, &#34;websocket&#34;):
        return await self.app(scope, receive, send)

    _, _, url = get_host_port_url_tuple(scope)
    if self.excluded_urls and self.excluded_urls.url_disabled(url):
        return await self.app(scope, receive, send)

    token = context.attach(extract(scope, getter=asgi_getter))
    span_name, additional_attributes = self.default_span_details(scope)

    messages = []
    more_body = True
    while more_body:
        message = await receive()
        messages.append(message)
        more_body = message.get(&#34;more_body&#34;, False)
    body = b&#39;&#39;.join([message.get(&#34;body&#34;, b&#34;&#34;) for message in messages])

    try:
        with self.tracer.start_as_current_span(
                span_name,
                kind=trace.SpanKind.SERVER,
        ) as span:
            if span.is_recording():
                attributes = collect_request_attributes(scope)
                attributes.update(additional_attributes)
                for key, value in attributes.items():
                    span.set_attribute(key, value)

            should_forward_to_handler = True
            if callable(self.server_request_hook):
                should_forward_to_handler = self.server_request_hook(span, scope, body)

            @wraps(receive)
            async def wrapped_receive():
                with self.tracer.start_as_current_span(
                        &#34; &#34;.join((span_name, scope[&#34;type&#34;], &#34;receive&#34;))
                ) as receive_span:
                    if messages:
                        return messages.pop(0)
                        # Once that&#39;s done we can just await any other messages.
                    if receive_span.is_recording():
                        if message[&#34;type&#34;] == &#34;websocket.receive&#34;:
                            set_status_code(receive_span, 200)
                        receive_span.set_attribute(&#34;type&#34;, message[&#34;type&#34;])
                    return await receive()

            @wraps(send)
            async def wrapped_send(message):
                send_span = span
                if callable(self.client_response_hook):
                    self.client_response_hook(send_span, message)
                if send_span.is_recording():
                    if message[&#34;type&#34;] == &#34;http.response.start&#34;:
                        status_code = message[&#34;status&#34;]
                        set_status_code(span, status_code)
                    elif message[&#34;type&#34;] == &#34;websocket.send&#34;:
                        set_status_code(span, 200)
                    elif message[&#34;type&#34;] == &#39;http.response.body&#39;:
                        pass
                await send(message)

            if should_forward_to_handler:
                await self.app(scope, wrapped_receive, wrapped_send)
            else:
                set_status_code(span, 403)
                raise HypertraceException(status_code=403)
    finally:
        context.detach(token)


OpenTelemetryMiddleware.__call__ = replaced_ot_middleware_call


class HypertraceException(HTTPException):
    &#34;&#34;&#34;An exception our middleware will raise if a filter determines to block the request&#34;&#34;&#34;

class FastAPIInstrumentorWrapper(BaseInstrumentorWrapper):
    &#34;&#34;&#34;Used to instrument fast api apps once an app has been loaded &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self.app = None

    def with_app(self, app):
        &#34;&#34;&#34;Need to defer instrumentation until we have a reference to the fast app
        during fastapi.FastAPI.setup this is invoked and stored so that we can then instrument&#34;&#34;&#34;
        self.app = app

    def instrument(self):
        &#34;&#34;&#34;Adds our error handler as well tracing middleware&#34;&#34;&#34;
        if self.app is None:
            print(&#34;No app defined, cant instrument fast api&#34;)
            return

        async def catch_exceptions_middleware(request: Request, call_next):
            try:
                return await call_next(request)
            except HypertraceException:
                return PlainTextResponse(status_code=403)

        # configure fast api instrumentor w hooks
        FastAPIInstrumentor.instrument_app(app=self.app,
                                           server_request_hook=self.server_request_hook,
                                           client_response_hook=self.client_response_hook)

        # Need to add exception middleware to the top of middleware stack
        # if instrument_app is added after this the exceptions wont be handled by us but by default
        # fast api handler(which results in 500 instead of 403)
        self.app.middleware(&#39;http&#39;)(catch_exceptions_middleware)

    def server_request_hook(self, span, req_data, body):
        &#34;&#34;&#34;this function is used to capture request attributes&#34;&#34;&#34;
        headers = dict(Headers(raw=req_data[&#39;headers&#39;]))
        request_url = str(Request(req_data).url)
        self.generic_request_handler(headers, body, span)

        block_result = Registry().apply_filters(span,
                                                request_url,
                                                headers,
                                                body,
                                                TYPE_HTTP)
        if block_result:
            logger.debug(&#39;should block evaluated to true, aborting with 403&#39;)
            return False
        return True

    def client_response_hook(self, span, resp_data):
        &#34;&#34;&#34;used to capture the response data
        this function is called twice, once during each resp_phase&#34;&#34;&#34;
        resp_phase = resp_data[&#39;type&#39;]
        if resp_phase == &#34;http.response.start&#34;:
            status_code = resp_data[&#34;status&#34;]
            set_status_code(span, status_code)
            headers = dict(Headers(raw=resp_data[&#39;headers&#39;]))
            should_capture_body = self._capture_headers(self._process_response_headers,
                                                        self.HTTP_RESPONSE_HEADER_PREFIX,
                                                        span, headers, self._process_response_body)
            span.set_attribute(&#39;hypertrace.capture&#39;, should_capture_body)

        elif resp_phase == &#39;http.response.body&#39;:
            should_capture = span.attributes.get(&#39;hypertrace.capture&#39;)
            if should_capture:
                body_data = resp_data[&#39;body&#39;]
                body_str = None
                if isinstance(body_data, bytes):
                    body_str = body_data.decode(&#39;UTF8&#39;, &#39;backslashreplace&#39;)
                else:
                    body_str = body_data

                resp_body_str = self.grab_first_n_bytes(body_str)
                span.set_attribute(&#39;http.response.body&#39;, resp_body_str)

    def uninstrument(self):
        &#34;&#34;&#34;Used to uninstrument fast api app&#34;&#34;&#34;
        if self.app:
            FastAPIInstrumentor.uninstrument_app(self.app)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="hypertrace.agent.instrumentation.fast_api.fast_api_auto_instrumentation_compat" href="fast_api_auto_instrumentation_compat.html">hypertrace.agent.instrumentation.fast_api.fast_api_auto_instrumentation_compat</a></code></dt>
<dd>
<div class="desc"><p>we need a post-settings configured hook for django; however that isn't available, but we can wrap
the application getters of wsgi/asgi to run our …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hypertrace.agent.instrumentation.fast_api.replaced_ot_middleware_call"><code class="name flex">
<span>async def <span class="ident">replaced_ot_middleware_call</span></span>(<span>self, scope, receive, send)</span>
</code></dt>
<dd>
<div class="desc"><p>The ASGI application</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scope</code></strong></dt>
<dd>A ASGI environment.</dd>
<dt><strong><code>receive</code></strong></dt>
<dd>An awaitable callable yielding dictionaries</dd>
<dt><strong><code>send</code></strong></dt>
<dd>An awaitable callable taking a single dictionary as argument.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def replaced_ot_middleware_call(self, scope, receive, send): # pylint:disable=R0914
    &#34;&#34;&#34;The ASGI application

    Args:
        scope: A ASGI environment.
        receive: An awaitable callable yielding dictionaries
        send: An awaitable callable taking a single dictionary as argument.
    &#34;&#34;&#34;
    if scope[&#34;type&#34;] not in (&#34;http&#34;, &#34;websocket&#34;):
        return await self.app(scope, receive, send)

    _, _, url = get_host_port_url_tuple(scope)
    if self.excluded_urls and self.excluded_urls.url_disabled(url):
        return await self.app(scope, receive, send)

    token = context.attach(extract(scope, getter=asgi_getter))
    span_name, additional_attributes = self.default_span_details(scope)

    messages = []
    more_body = True
    while more_body:
        message = await receive()
        messages.append(message)
        more_body = message.get(&#34;more_body&#34;, False)
    body = b&#39;&#39;.join([message.get(&#34;body&#34;, b&#34;&#34;) for message in messages])

    try:
        with self.tracer.start_as_current_span(
                span_name,
                kind=trace.SpanKind.SERVER,
        ) as span:
            if span.is_recording():
                attributes = collect_request_attributes(scope)
                attributes.update(additional_attributes)
                for key, value in attributes.items():
                    span.set_attribute(key, value)

            should_forward_to_handler = True
            if callable(self.server_request_hook):
                should_forward_to_handler = self.server_request_hook(span, scope, body)

            @wraps(receive)
            async def wrapped_receive():
                with self.tracer.start_as_current_span(
                        &#34; &#34;.join((span_name, scope[&#34;type&#34;], &#34;receive&#34;))
                ) as receive_span:
                    if messages:
                        return messages.pop(0)
                        # Once that&#39;s done we can just await any other messages.
                    if receive_span.is_recording():
                        if message[&#34;type&#34;] == &#34;websocket.receive&#34;:
                            set_status_code(receive_span, 200)
                        receive_span.set_attribute(&#34;type&#34;, message[&#34;type&#34;])
                    return await receive()

            @wraps(send)
            async def wrapped_send(message):
                send_span = span
                if callable(self.client_response_hook):
                    self.client_response_hook(send_span, message)
                if send_span.is_recording():
                    if message[&#34;type&#34;] == &#34;http.response.start&#34;:
                        status_code = message[&#34;status&#34;]
                        set_status_code(span, status_code)
                    elif message[&#34;type&#34;] == &#34;websocket.send&#34;:
                        set_status_code(span, 200)
                    elif message[&#34;type&#34;] == &#39;http.response.body&#39;:
                        pass
                await send(message)

            if should_forward_to_handler:
                await self.app(scope, wrapped_receive, wrapped_send)
            else:
                set_status_code(span, 403)
                raise HypertraceException(status_code=403)
    finally:
        context.detach(token)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="hypertrace.agent.instrumentation.fast_api.FastAPIInstrumentorWrapper"><code class="flex name class">
<span>class <span class="ident">FastAPIInstrumentorWrapper</span></span>
</code></dt>
<dd>
<div class="desc"><p>Used to instrument fast api apps once an app has been loaded </p>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FastAPIInstrumentorWrapper(BaseInstrumentorWrapper):
    &#34;&#34;&#34;Used to instrument fast api apps once an app has been loaded &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self.app = None

    def with_app(self, app):
        &#34;&#34;&#34;Need to defer instrumentation until we have a reference to the fast app
        during fastapi.FastAPI.setup this is invoked and stored so that we can then instrument&#34;&#34;&#34;
        self.app = app

    def instrument(self):
        &#34;&#34;&#34;Adds our error handler as well tracing middleware&#34;&#34;&#34;
        if self.app is None:
            print(&#34;No app defined, cant instrument fast api&#34;)
            return

        async def catch_exceptions_middleware(request: Request, call_next):
            try:
                return await call_next(request)
            except HypertraceException:
                return PlainTextResponse(status_code=403)

        # configure fast api instrumentor w hooks
        FastAPIInstrumentor.instrument_app(app=self.app,
                                           server_request_hook=self.server_request_hook,
                                           client_response_hook=self.client_response_hook)

        # Need to add exception middleware to the top of middleware stack
        # if instrument_app is added after this the exceptions wont be handled by us but by default
        # fast api handler(which results in 500 instead of 403)
        self.app.middleware(&#39;http&#39;)(catch_exceptions_middleware)

    def server_request_hook(self, span, req_data, body):
        &#34;&#34;&#34;this function is used to capture request attributes&#34;&#34;&#34;
        headers = dict(Headers(raw=req_data[&#39;headers&#39;]))
        request_url = str(Request(req_data).url)
        self.generic_request_handler(headers, body, span)

        block_result = Registry().apply_filters(span,
                                                request_url,
                                                headers,
                                                body,
                                                TYPE_HTTP)
        if block_result:
            logger.debug(&#39;should block evaluated to true, aborting with 403&#39;)
            return False
        return True

    def client_response_hook(self, span, resp_data):
        &#34;&#34;&#34;used to capture the response data
        this function is called twice, once during each resp_phase&#34;&#34;&#34;
        resp_phase = resp_data[&#39;type&#39;]
        if resp_phase == &#34;http.response.start&#34;:
            status_code = resp_data[&#34;status&#34;]
            set_status_code(span, status_code)
            headers = dict(Headers(raw=resp_data[&#39;headers&#39;]))
            should_capture_body = self._capture_headers(self._process_response_headers,
                                                        self.HTTP_RESPONSE_HEADER_PREFIX,
                                                        span, headers, self._process_response_body)
            span.set_attribute(&#39;hypertrace.capture&#39;, should_capture_body)

        elif resp_phase == &#39;http.response.body&#39;:
            should_capture = span.attributes.get(&#39;hypertrace.capture&#39;)
            if should_capture:
                body_data = resp_data[&#39;body&#39;]
                body_str = None
                if isinstance(body_data, bytes):
                    body_str = body_data.decode(&#39;UTF8&#39;, &#39;backslashreplace&#39;)
                else:
                    body_str = body_data

                resp_body_str = self.grab_first_n_bytes(body_str)
                span.set_attribute(&#39;http.response.body&#39;, resp_body_str)

    def uninstrument(self):
        &#34;&#34;&#34;Used to uninstrument fast api app&#34;&#34;&#34;
        if self.app:
            FastAPIInstrumentor.uninstrument_app(self.app)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hypertrace.agent.instrumentation.BaseInstrumentorWrapper" href="../index.html#hypertrace.agent.instrumentation.BaseInstrumentorWrapper">BaseInstrumentorWrapper</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hypertrace.agent.instrumentation.fast_api.FastAPIInstrumentorWrapper.client_response_hook"><code class="name flex">
<span>def <span class="ident">client_response_hook</span></span>(<span>self, span, resp_data)</span>
</code></dt>
<dd>
<div class="desc"><p>used to capture the response data
this function is called twice, once during each resp_phase</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def client_response_hook(self, span, resp_data):
    &#34;&#34;&#34;used to capture the response data
    this function is called twice, once during each resp_phase&#34;&#34;&#34;
    resp_phase = resp_data[&#39;type&#39;]
    if resp_phase == &#34;http.response.start&#34;:
        status_code = resp_data[&#34;status&#34;]
        set_status_code(span, status_code)
        headers = dict(Headers(raw=resp_data[&#39;headers&#39;]))
        should_capture_body = self._capture_headers(self._process_response_headers,
                                                    self.HTTP_RESPONSE_HEADER_PREFIX,
                                                    span, headers, self._process_response_body)
        span.set_attribute(&#39;hypertrace.capture&#39;, should_capture_body)

    elif resp_phase == &#39;http.response.body&#39;:
        should_capture = span.attributes.get(&#39;hypertrace.capture&#39;)
        if should_capture:
            body_data = resp_data[&#39;body&#39;]
            body_str = None
            if isinstance(body_data, bytes):
                body_str = body_data.decode(&#39;UTF8&#39;, &#39;backslashreplace&#39;)
            else:
                body_str = body_data

            resp_body_str = self.grab_first_n_bytes(body_str)
            span.set_attribute(&#39;http.response.body&#39;, resp_body_str)</code></pre>
</details>
</dd>
<dt id="hypertrace.agent.instrumentation.fast_api.FastAPIInstrumentorWrapper.instrument"><code class="name flex">
<span>def <span class="ident">instrument</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds our error handler as well tracing middleware</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def instrument(self):
    &#34;&#34;&#34;Adds our error handler as well tracing middleware&#34;&#34;&#34;
    if self.app is None:
        print(&#34;No app defined, cant instrument fast api&#34;)
        return

    async def catch_exceptions_middleware(request: Request, call_next):
        try:
            return await call_next(request)
        except HypertraceException:
            return PlainTextResponse(status_code=403)

    # configure fast api instrumentor w hooks
    FastAPIInstrumentor.instrument_app(app=self.app,
                                       server_request_hook=self.server_request_hook,
                                       client_response_hook=self.client_response_hook)

    # Need to add exception middleware to the top of middleware stack
    # if instrument_app is added after this the exceptions wont be handled by us but by default
    # fast api handler(which results in 500 instead of 403)
    self.app.middleware(&#39;http&#39;)(catch_exceptions_middleware)</code></pre>
</details>
</dd>
<dt id="hypertrace.agent.instrumentation.fast_api.FastAPIInstrumentorWrapper.server_request_hook"><code class="name flex">
<span>def <span class="ident">server_request_hook</span></span>(<span>self, span, req_data, body)</span>
</code></dt>
<dd>
<div class="desc"><p>this function is used to capture request attributes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def server_request_hook(self, span, req_data, body):
    &#34;&#34;&#34;this function is used to capture request attributes&#34;&#34;&#34;
    headers = dict(Headers(raw=req_data[&#39;headers&#39;]))
    request_url = str(Request(req_data).url)
    self.generic_request_handler(headers, body, span)

    block_result = Registry().apply_filters(span,
                                            request_url,
                                            headers,
                                            body,
                                            TYPE_HTTP)
    if block_result:
        logger.debug(&#39;should block evaluated to true, aborting with 403&#39;)
        return False
    return True</code></pre>
</details>
</dd>
<dt id="hypertrace.agent.instrumentation.fast_api.FastAPIInstrumentorWrapper.uninstrument"><code class="name flex">
<span>def <span class="ident">uninstrument</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Used to uninstrument fast api app</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uninstrument(self):
    &#34;&#34;&#34;Used to uninstrument fast api app&#34;&#34;&#34;
    if self.app:
        FastAPIInstrumentor.uninstrument_app(self.app)</code></pre>
</details>
</dd>
<dt id="hypertrace.agent.instrumentation.fast_api.FastAPIInstrumentorWrapper.with_app"><code class="name flex">
<span>def <span class="ident">with_app</span></span>(<span>self, app)</span>
</code></dt>
<dd>
<div class="desc"><p>Need to defer instrumentation until we have a reference to the fast app
during fastapi.FastAPI.setup this is invoked and stored so that we can then instrument</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_app(self, app):
    &#34;&#34;&#34;Need to defer instrumentation until we have a reference to the fast app
    during fastapi.FastAPI.setup this is invoked and stored so that we can then instrument&#34;&#34;&#34;
    self.app = app</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hypertrace.agent.instrumentation.BaseInstrumentorWrapper" href="../index.html#hypertrace.agent.instrumentation.BaseInstrumentorWrapper">BaseInstrumentorWrapper</a></b></code>:
<ul class="hlist">
<li><code><a title="hypertrace.agent.instrumentation.BaseInstrumentorWrapper.add_headers_to_span" href="../index.html#hypertrace.agent.instrumentation.BaseInstrumentorWrapper.add_headers_to_span">add_headers_to_span</a></code></li>
<li><code><a title="hypertrace.agent.instrumentation.BaseInstrumentorWrapper.check_body_size" href="../index.html#hypertrace.agent.instrumentation.BaseInstrumentorWrapper.check_body_size">check_body_size</a></code></li>
<li><code><a title="hypertrace.agent.instrumentation.BaseInstrumentorWrapper.eligible_based_on_content_type" href="../index.html#hypertrace.agent.instrumentation.BaseInstrumentorWrapper.eligible_based_on_content_type">eligible_based_on_content_type</a></code></li>
<li><code><a title="hypertrace.agent.instrumentation.BaseInstrumentorWrapper.generic_request_handler" href="../index.html#hypertrace.agent.instrumentation.BaseInstrumentorWrapper.generic_request_handler">generic_request_handler</a></code></li>
<li><code><a title="hypertrace.agent.instrumentation.BaseInstrumentorWrapper.generic_response_handler" href="../index.html#hypertrace.agent.instrumentation.BaseInstrumentorWrapper.generic_response_handler">generic_response_handler</a></code></li>
<li><code><a title="hypertrace.agent.instrumentation.BaseInstrumentorWrapper.generic_rpc_request_handler" href="../index.html#hypertrace.agent.instrumentation.BaseInstrumentorWrapper.generic_rpc_request_handler">generic_rpc_request_handler</a></code></li>
<li><code><a title="hypertrace.agent.instrumentation.BaseInstrumentorWrapper.generic_rpc_response_handler" href="../index.html#hypertrace.agent.instrumentation.BaseInstrumentorWrapper.generic_rpc_response_handler">generic_rpc_response_handler</a></code></li>
<li><code><a title="hypertrace.agent.instrumentation.BaseInstrumentorWrapper.grab_first_n_bytes" href="../index.html#hypertrace.agent.instrumentation.BaseInstrumentorWrapper.grab_first_n_bytes">grab_first_n_bytes</a></code></li>
<li><code><a title="hypertrace.agent.instrumentation.BaseInstrumentorWrapper.lowercase_headers" href="../index.html#hypertrace.agent.instrumentation.BaseInstrumentorWrapper.lowercase_headers">lowercase_headers</a></code></li>
<li><code><a title="hypertrace.agent.instrumentation.BaseInstrumentorWrapper.set_body_max_size" href="../index.html#hypertrace.agent.instrumentation.BaseInstrumentorWrapper.set_body_max_size">set_body_max_size</a></code></li>
<li><code><a title="hypertrace.agent.instrumentation.BaseInstrumentorWrapper.set_process_request_body" href="../index.html#hypertrace.agent.instrumentation.BaseInstrumentorWrapper.set_process_request_body">set_process_request_body</a></code></li>
<li><code><a title="hypertrace.agent.instrumentation.BaseInstrumentorWrapper.set_process_request_headers" href="../index.html#hypertrace.agent.instrumentation.BaseInstrumentorWrapper.set_process_request_headers">set_process_request_headers</a></code></li>
<li><code><a title="hypertrace.agent.instrumentation.BaseInstrumentorWrapper.set_process_response_body" href="../index.html#hypertrace.agent.instrumentation.BaseInstrumentorWrapper.set_process_response_body">set_process_response_body</a></code></li>
<li><code><a title="hypertrace.agent.instrumentation.BaseInstrumentorWrapper.set_process_response_headers" href="../index.html#hypertrace.agent.instrumentation.BaseInstrumentorWrapper.set_process_response_headers">set_process_response_headers</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hypertrace.agent.instrumentation.fast_api.HypertraceException"><code class="flex name class">
<span>class <span class="ident">HypertraceException</span></span>
<span>(</span><span>status_code: int, detail: Any = None, headers: Optional[Dict[str, str]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>An exception our middleware will raise if a filter determines to block the request</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HypertraceException(HTTPException):
    &#34;&#34;&#34;An exception our middleware will raise if a filter determines to block the request&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>fastapi.exceptions.HTTPException</li>
<li>starlette.exceptions.HTTPException</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hypertrace.agent.instrumentation" href="../index.html">hypertrace.agent.instrumentation</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="hypertrace.agent.instrumentation.fast_api.fast_api_auto_instrumentation_compat" href="fast_api_auto_instrumentation_compat.html">hypertrace.agent.instrumentation.fast_api.fast_api_auto_instrumentation_compat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="hypertrace.agent.instrumentation.fast_api.replaced_ot_middleware_call" href="#hypertrace.agent.instrumentation.fast_api.replaced_ot_middleware_call">replaced_ot_middleware_call</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="hypertrace.agent.instrumentation.fast_api.FastAPIInstrumentorWrapper" href="#hypertrace.agent.instrumentation.fast_api.FastAPIInstrumentorWrapper">FastAPIInstrumentorWrapper</a></code></h4>
<ul class="">
<li><code><a title="hypertrace.agent.instrumentation.fast_api.FastAPIInstrumentorWrapper.client_response_hook" href="#hypertrace.agent.instrumentation.fast_api.FastAPIInstrumentorWrapper.client_response_hook">client_response_hook</a></code></li>
<li><code><a title="hypertrace.agent.instrumentation.fast_api.FastAPIInstrumentorWrapper.instrument" href="#hypertrace.agent.instrumentation.fast_api.FastAPIInstrumentorWrapper.instrument">instrument</a></code></li>
<li><code><a title="hypertrace.agent.instrumentation.fast_api.FastAPIInstrumentorWrapper.server_request_hook" href="#hypertrace.agent.instrumentation.fast_api.FastAPIInstrumentorWrapper.server_request_hook">server_request_hook</a></code></li>
<li><code><a title="hypertrace.agent.instrumentation.fast_api.FastAPIInstrumentorWrapper.uninstrument" href="#hypertrace.agent.instrumentation.fast_api.FastAPIInstrumentorWrapper.uninstrument">uninstrument</a></code></li>
<li><code><a title="hypertrace.agent.instrumentation.fast_api.FastAPIInstrumentorWrapper.with_app" href="#hypertrace.agent.instrumentation.fast_api.FastAPIInstrumentorWrapper.with_app">with_app</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hypertrace.agent.instrumentation.fast_api.HypertraceException" href="#hypertrace.agent.instrumentation.fast_api.HypertraceException">HypertraceException</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>